# Sanity Documentation Consolidated

This file consolidates content from various Sanity.io documentation pages into a single markdown file for easy ingestion by a coding agent. Each section includes the original page title, a link to the source page, and the extracted content. Links within the content point to original documentation pages where applicable.

## Home [https://www.sanity.io/docs]

# Home | Sanity Docs

# Sanity Docs

Start building with Sanity's Content Operating System. Explore guides, examples, resources, and references for our platform and applications.

Search or Ask AI... CTRL K

###### Quickstarts

## Getting started

Set up Sanity with your favorite framework in minutes.

[Or start with a template â†’](https://www.sanity.io/templates?ref=docs)

[Popular destinations](#ee48fd533fc8)

#### How schemas work

Learn about schema types and how to create content models

#### GROQ Cheat sheet

Quick reference for common query patterns with GROQ

#### Visual Editing

Set up live preview, click-to-edit, drag'n'drop for Sanity Studio

#### Sanity MCP server

Enable AI assistants to interact with your Sanity workspace through the Model Context Protocol (MCP).

#### Best practices for AI-powered Sanity development

Set up the Sanity Agent Toolkit and MCP server to help AI assistants generate high-quality Sanity code that follows established best practices.

[The Content Operating System](#k5752ab9c8a0c)

#### Content Lake

Real-time database for structured content

#### Compute and AI

Run business logic, automate workflows with AI

#### APIs and SDKs

Developer tools that power your entire content lifecycle

[Sanity Apps](#ecbe65b974be)

#### Studio

Fully featured, customizable multiplayer CMS

#### Canvas

AI-powered distraction-free writing

#### Media Library

Centralized asset management for orgs

#### Dashboard

Where you can run your apps in a unified interface

#### App SDK

Build any content operations app

[Reference](#k8ea3a8c87124)

#### Schema

A schema describes the types of documents and fields editors may author in a Sanity Studio workspace.

#### HTTP API

Interactive reference for HTTP endpoints

#### Library Reference Docs

Typedoc reference documentation for Sanity's JS-based libraries and SDKs

#### CLI

Command Line Interface for local development

#### Tools and libraries

Integration, tools, and utilities for Sanity development

[Resources](#k69cdfdf0b823d78d0dce20ce175d6a05)

#### Developer guides

Official implementation guides for common patterns and solutions

#### Courses and certifications

Get work-ready with Sanity

#### Join the community

Get help, share projects, and hang out with other Sanity devs

#### Explore templates

Official and community contributed templates to kick-start a new project or get inspired from

#### User guides

Guides for apps and user interfaces for those who work with content

## Product Updates & Release Notes [https://www.sanity.io/docs/changelog]

# Product Updates & Release Notes | Sanity Docs

# Changelog

Track new features, improvements, and fixes across all Sanity products.

December 22, 2025

## Minor bugfixes and improvements

December 18, 2025

## Automatic markdown formatting on paste

December 17, 2025

## Asset URLs that stay current and improved link handling

December 17, 2025

## Synced pins, UI and performance improvements, and bugfixes

December 17, 2025

## Minor bugfixes and improvements

December 16, 2025

## Support for initial values in document creation and new agent capabilities

December 15, 2025

## React 19.2 as baseline, TypeGen improvements

December 15, 2025

## Smart typography in the Portable Text Editor, and minor bugfixes

December 11, 2025

## Sanity MCP Server GA: remote server, schema deployment, and new tools

December 11, 2025

## Copy as markdown support, additional keyboard shortcuts

December 11, 2025

## Clarify React 19 CLI message, minor fixes

December 9, 2025

## Configure Sanity MCP server with CLI, updated blueprint commands + improvements and bugfixes

December 4, 2025

## fix unsupported expression TSAsExpression error in typegen

December 4, 2025

## Fixes schema extract and typegen "traverse is not a function" errors

December 4, 2025

## Fixes ERR_REQUIRE_CYCLE_MODULE and upgrade React to 19.2.1

December 2, 2025

## New schema validate command, improvements to scheduled drafts, and multiple fixes

December 1, 2025

## Added keyboard shortcuts for styling and comments

November 28, 2025

## Faster changelog pages, SanityLive is back, and fall refresh of older docs.

November 27, 2025

## More intuitive exports, better type support, and modernized library

November 26, 2025

## Redesigned aspects sidebar + improvements and bug fixes

## Help and troubleshooting [https://www.sanity.io/docs/help]

# Help and troubleshooting | Sanity Docs

Help articles Last updated September 19, 2025

# Help and troubleshooting

Here you'll find articles for troubleshooting errors, migrating versions, and more.

[Most popular](#ecc2ff33c1af)

#### Studio v3 to v4

Upgrading to v4 adds Node.js 20 as a requirement and requires minimal, if any, changes in your apps.

#### React 19 and Sanity

Get ready to upgrade Sanity Studio and official plugins to React 19.

#### React Compiler and Sanity

Learn how to use the React Compiler with Sanity Studio, React 18 & 19, and for publishing Sanity plugins. Improve performance and reduce manual memoization.

#### CLI errors

#### Object type has a invalid value for fields

#### API versioning in Javascript Client

## Studio [https://www.sanity.io/docs/studio]

# Studio | Sanity Docs

Studio Last updated September 8, 2025

# Studio

Sanity Studio is an open-source, real-time collaborative content workbench where developers define content models using JavaScript objects. The Studio automatically generates a powerful editing environment based on these definitions, while offering extensive customization options through a React-based framework to tailor the editorial experience to your specific workflows.

[The basics](#k0b6bdfd0-d81f-476c-96e7-6977c0c7c956)

#### Configuration

Sanity Studio lets you quickly get up and running by configuring it with simple JavaScript or TypeScript.

#### Schema types

Add out-of-the-box and custom document and field types

#### Block Content

Rich text and custom block content that can render in any front end

#### Sanity Studio quickstart

[Get ready for production](#k47d73027aa2d)

#### Visual Editing

Add shareable live previews, click-to-edit, and drag and drop

#### Hosting and deployment

How to deploy Sanity Studio, either on your own or using our hosted service.

#### Studio versions and auto-updating

Explore the features and improvements in the latest version of Sanity.

[Customize the Studio](#b43004e27b4d)

#### Custom components

Introduction to custom components for Sanity Studio

#### Structure builder

Customize document lists, views, menus, and more

#### Localize the Studio

How to get the Studio in any language

[Bells and whistles](#edc571dd2e60)

#### Comments for Sanity Studio

Learn to use Comments in Sanity Studio for effective collaboration, including leaving comments, @mentions, and resolving comments.

#### Tasks for Sanity Studio

Learn to use Sanity Studio's tasks for collaboration, assign tasks, comment on tasks, and resolve tasks for efficient content creation.

#### Content releases

Organize and schedule updates across multiple documents.

#### Localizing Sanity Studio

Sanity Studio supports UI localization via plugins. Users can install languages, override translations, and contribute to localization.

#### Install and configure Sanity AI Assist

How to install and configure the AI Assist plugin for Sanity Studio.

## Libraries and tooling [https://www.sanity.io/docs/libraries]

# Libraries and tooling | Sanity Docs

Libraries Last updated May 15, 2025

# Libraries and tooling

Integrate your content with applications and front end frameworks. Use specialized tooling for customization and working with content as data.

[Clients](#k255f90beb007)

#### JavaScript Client

The official Sanity JS Client

#### PHP Client

The official Sanity PHP Client

#### Rust Client

Community-supported Sanity Rust Client

#### LINQ (C#) Client

Community-supported Sanity LINQ Client

#### Flutter Client

Community Supported Sanity Flutter Client

[Portable Text](#k4e51ca12c52e)

#### Editor Playground

Explore the Portable Text Editor

#### Standalone Portable Text Editor

Portable Text Editor on demand!

#### React serializer

Present Portable Text in React

#### Vue serializer

Present Portable Text in Vue

#### Svelte serializer

Present Portable Text in Svelte

#### HTML serializer

Present Portable Text in plain HTML

[Frontend tooling](#feea685e6706)

The all-in-one Sanity toolkit for production-grade content-editable Next.js applications.

#### Nuxt module

Just bring your sanity.config.ts - no additional configuration required

#### Astro integration

The web framework for content-driven websites.

## Specifications [https://www.sanity.io/docs/specifications]

# Specifications | Sanity Docs

Specifications Last updated May 15, 2025

# Specifications

Specifications and standards used throughout the Sanity ecosystem and maintained by the Sanity team.

[Query language](#k5c69dd83a3cb)

#### GROQ syntax

Reference documentation for the GROQ syntax.

#### GROQ data types

Data types supported by GROQ

#### GROQ Functions Reference

Reference documentation for GROQ functions.

#### Full GROQ spec

The base GROQ specification

[Compute and AI](#k5cfd50fa985c)

#### Blueprint configuration reference

Reference documentation for the Blueprint configuration files.

#### Function handler reference

Reference documentation for the shape of the function wrapper.

[Beyond Sanity](#k862fac7b41b0)

#### Portable Text

The rich text editor and structured content specification that powers Studio's block editor.

#### Content Source Maps

Associate rendered content with its original source.

#### Mendoza

The specification that powers the way Sanity diffs patches.

## Canvas [https://www.sanity.io/docs/canvas]

# Canvas | Sanity Docs

Canvas Last updated November 20, 2025

# Canvas

A place to author content that embraces the creative process and helps you deliver better and faster with seamless hand-off to your front end. Work with templates, an AI ghostwriter, and map content back to Studio.

[Explore Canvas](#e6956b00910e)

#### Introduction to Canvas

Canvas is a writing tool that empowers content creation with AI assistance and contextual notes. Craft informed, engaging content effortlessly.

#### Content mapping for Canvas

Bridge the gap between Canvas and Studio with content mapping

#### Configure content mapping

Learn how to set up and configure content mapping to bridge the gap between Sanity Canvas and Sanity Studio, giving your content team the best of both worlds.

## Dashboard [https://www.sanity.io/docs/dashboard]

# Dashboard | Sanity Docs

# Dashboard

Dashboard Last updated November 17, 2025

The dashboard is your one-stop content operations hub. All your organization's studios and custom apps in one shared space.

[Custom apps for Dashboard](#bdbac12d9a4b)

#### App SDK

Create custom apps on the Sanity platform with the App SDK.

#### App SDK Quickstart Guide

Get up and running quickly with the Sanity App SDK by following this step-by-step guide!

## Comments for Sanity Studio [https://www.sanity.io/docs/studio/comments]

# Comments for Sanity Studio | Sanity Docs

Studio Last updated September 4, 2025

# Comments for Sanity Studio

Copy article

Learn to use Comments in Sanity Studio for effective collaboration, including leaving comments, @mentions, and resolving comments.

Comments for Sanity Studio enables effective collaboration workflows right where the work is done. Leave comments on specific document fields or even single words in Portable Text, *@mention* your colleagues, and streamline your content workflow without ever leaving the studio.

#### This is a paid feature

This feature is available in the [Growth plan.](/pricing)

#### Enable Comments for Sanity Studio

Learn how to enable and configure Comments for Sanity Studio

#### Enabling Tasks for Sanity Studio

Enable and configure Tasks for Sanity Studio

[Comments workflow](#k26d7734285f4)

Once Comments has been enabled for your project, open any document in your studio to start exploring how they work. If someone has already left comments on any field in the document you will notice a small speech bubble icon ðŸ’¬ adorning the input showing how many comments have been posted. If no comments have yet been posted, hover any field to bring up the speech bubble to leave the first!

[Leaving comments](#c91d562cc890)

Hover over any comment-enabled field and click on the comment icon ðŸ’¬ to open a popover dialog, then type your comment in the input field and hit **Send** to post it.

To mention a colleague, type **@** followed by their name. A list of users with access to the document will appear. Click on the user you want to mention, and they will receive an email notification.

Your comment will now be visible to others with access to the document, and any mentioned users will receive a notification by email.

Unlike their closely related cousin [Tasks](/docs/studio/tasks) , comments are always directly coupled with a specific piece of content in your studio. Comments can be attached to any compatible field, or even to distinct sentences or words within Portable Text!

Clicking the ðŸ’¬ comments icon on a field, will open the comment inbox for the document so you can easily browse through existing comments. Comments are neatly grouped into the fields they correspond to.

[Resolving comments](#k3f44d42dbe97)

When a comment has been addressed or is no longer relevant, you can mark it as resolved. To do this, click on the **Resolve** option in the popover menu that appears when hovering. Resolved comments will be hidden from the main view but can still be accessed in the **Resolved Comments** list.

*Shows a comment being resolved*

[Reactions, editing, and deleting comments](#d44bc2bcf426)

In addition to resolving comments, the popover menu includes a few more options. You can leave a reaction emoji for effective communication, copy a direct link to the comment, and you have options to edit or delete your comment. These options all work as you'd expect.

[Comment notifications](#c7debac0b774)

You'll receive notifications when tagged in a comment. You can adjust notifications in your user settings, as shown in the [Notifications](/docs/studio/studio-notifications) documentation.

#### Incorrect links with external studios?

If your studio is hosted externally, it must be added to the Studio's list for the project in [sanity.io/manage](https://www.sanity.io/manage) in order for notification links to point to the correct studio.

Was this page helpful?

Report issue

## Validation [https://www.sanity.io/docs/studio/validation]

# Validation | Sanity Docs

Studio Last updated November 24, 2025

# Validation

Copy article

Describes how to validate documents within the content studio.

Sanity Studio allows you to specify validation rules on your document types and fields. Field-level validation is the most specific and gives the Studio a better chance to help the user understand where the validation failed and why, whereas the document-level validation provides slightly more control since it can validate based on the values of the entire document.

Each schema type has a set of built-in validation methods. [See the schema type documentation for a detailed list â†’](/docs/schema-types)

#### Protip

Validation rules run in the Studio as an editor is working in a document. You can also [validate multiple documents in bulk using the CLI](/docs/content-lake/schema-and-content-migrations#b9ea24e2a1e3) .

[Basics](#k4dc8b38bc411)

Validation is defined by setting the `validation` property on a document type or field. It takes a function which receives a rule as the first argument. By calling methods on this rule, you add new validation modifiers. Here's an example which validates that a string field has a value and that the string is between 10 and 80 characters long:

```
defineField({
  title: 'Title',
  name: 'title',
  type: 'string',
  validation: rule => rule.required().min(10).max(80)
})
```

Without the `required()` call, the title is also considered valid if it does not have a value.

[Error levels and error messages](#k812ebcd2ff64)

By default, values that do not pass the validation rules are considered errors - these will block the draft from being published until they have been resolved. You can also set a rule to be a warning, simply by calling `warning()` on the rule. Similarly, you can customize the error message displayed by passing a string to the `warning()` or `error()` method:

```
defineField({
  title: 'Title',
  name: 'title',
  type: 'string',
  validation: rule => rule.max(50).warning('Shorter titles are usually better')
})
```

If you want to combine both warnings and errors in the same validation set, you can use an array:

```
defineField({
  title: 'Title',
  name: 'title',
  type: 'string',
  validation: rule => [
    rule.required().min(10).error('A title of min. 10 characters is required'),
    rule.max(50).warning('Shorter titles are usually better')
  ]
})
```

[Referencing other fields](#k1d8eb8fbb695)

Sometimes you may want to build a rule that is based on the value of a different field. By calling the `rule.valueOfField` method, you can achieve this.

```
defineField({
  title: 'Start date',
  name: 'startDate',
  type: 'datetime',
  validation: rule => rule.required().min('2022-03-01T15:00:00.000Z')
}),
defineField({
  title: 'End date',
  name: 'endDate',
  type: 'datetime',
  validation: rule => rule.required().min(rule.valueOfField('startDate'))
})
```

Note however that it only allows referencing sibling fields. If you need to refer to things outside of this scope, you will have to use document-level validation.

#### Gotcha

`rule.valueOfField()` returns the literal value of a field, allowing you to validate that the end date is always equal to or greater than the start date (as in the previous example). However, it cannot be used for inserting a field value into conditional logic and creating a validation based on the result.

[Custom validation](#k091e10f957aa)

Sometimes you will need to validate values beyond what Sanity provides. The `custom()` method allows you to do this. It takes a function as the first argument, which should return either `true` (in the case of a valid value) or an error message as a string (in the case of an invalid value). You may also return a promise that resolves with one of those values, should you need to do asynchronous operations:

```
defineField({
  name: 'location',
  type: 'geopoint',
  title: 'Location of bar',
  description: 'Required, must be in Norway',
  validation: rule =>
    rule.required().custom(geoPoint =>
      someGeoService
        .isWithinBounds(
          {
            latitude: geoPoint.lat,
            longitude: geoPoint.lng
          },
          someGeoService.BOUNDS_NORWAY
        )
        .then(isWithinBounds => (isWithinBounds ? true : 'Location must be in Norway, somewhere'))
    )
})
```

Please note that custom validators are also run on undefined values, unless the rule is explicitly set as optional by calling `rule.optional()` . This allows for conditionally allowing undefined values based on some external factor, with the slight drawback that you need to make sure your functions check for undefined values. Here's an example:

```
defineField({
  name: 'breweryName',
  type: 'string',
  title: 'Brewery name',
  validation: rule => rule.custom(name => {
    if (typeof name === 'undefined') {
      return true // Allow undefined values
    }
    
    // This would crash if we didn't check
    // for undefined values first
    return name.startsWith('Brew')
      ? 'Please be more creative'
      : true
  }).warning()
})
```

Should you need to reference other fields from within the custom validator function, you can use the second argument ( `context` ) to the function:

```
defineField({
  name: 'durationInMinutes',
  type: 'number',
  title: 'Duration of talk, in minutes',
  validation: rule => rule.custom((duration, context) => {
    const isShortTalk = duration && duration <= 10
    if (isShortTalk && context.document.talkType !== 'lightning') {
      return 'Only lightning talks should be 10 minutes or less'
    }
    
    return true
  })
})
```

You can also access the closest `parent` from the context, along with the `path` of the current element being validated.

[Asynchronous validation using the client](#k71fb43753fd9)

If you want to base your rule on another part of your content, you can access the client via the validation context.

```
validation: (Rule) =>
  Rule.custom((value, context) => {
    const client = context.getClient({apiVersion: '2021-03-25'}).withConfiguration({perspective: 'previewDrafts'})
    // rest of your rule
},
```

[Validating children](#k9e69d5db6f72)

In certain cases, you may want to validate children of an object or array. In this case you can return an object containing a `message` and a `paths` property. Each path is an array of *path segments* leading to the child you want to flag as being the culprit. Let's say you want to disallow empty blocks/paragraphs in a portable text field:

```
defineField({
  name: 'introduction',
  title: 'Introduction',
  type: 'array',
  of: [{type: 'block'}],
  validation: rule => rule.custom(blocks => {
    const emptyBlocks = (blocks || []).filter(
      block =>
        block._type === 'block' &&
        block.children.every(span =>
          span._type === 'span' &&
          span.text.trim() === ''
        )
    )
    
    const emptyPaths = emptyBlocks.map(
      (block, index) => [{_key: block._key}] || [index]
    )

    return emptyPaths.length === 0
      ? true
      : {
          message: 'Paragraph cannot be empty',
          paths: emptyPaths
        }
  })
})
```

For each of the empty blocks we find, we collect the path to it, which can either be the `_key` property (preferably), or the array index if a key cannot be found.

[Document level validation](#k053289e55848)

Sometimes you want to validate a whole document rather than just specific fields in a document. To do this, you can give a document the `validation` property and access fields inside the document by passing a prop. In this example, the validation ensures that editors can't add a "Guest Author" and an "Author."

```
export default defineType({
  name: 'post',
  type: 'document',
  title: 'Blog Post',
  validation: rule => rule.custom(fields => {
    if (fields.authors.length > 0 && Object.keys(fields.guest).length > 0) return "You can't have an author AND guest author"
    return true
  }),
  fields: [
    // ... 
    defineField({
      name: 'authors',
      title: 'Authors',
      type: 'array',
      of: [
        {
          type: 'authorReference',
        }
      ]
    }),
    defineField({
      name: 'guest',
      title: 'Guest Author',
      type: 'object',
      fields: [
        {name: 'name', type: 'string', title: 'Guest Author Name'},
        {name: 'site', type: 'string', title: 'Guest Author Site'},
      ],
    }),
  ]
})
```

[Marking nested fields as invalid](#d5518a843c86)

Similar to the example in "Validating children" above, you can return an object to specify what field the message should apply to when using document level validation.

```
export default defineType({
    name: 'post',
    type: 'document',
    title: 'Blog Post',
    validation: (rule) =>
        rule.custom((fields) => {
            if (
                fields.authors.length > 0 &&
                Object.keys(fields.guest).length > 0
            )
                return {
                    message: "You can't have an author AND guest author",
                    path: ['guest'], // add keys to array for nested fields, ex ['guest', 'title'] for guest.title
                }
            return true
        }),
    fields: [
        // ...
        defineField({
            name: 'authors',
            title: 'Authors',
            type: 'array',
            of: [
                {
                    type: 'authorReference',
                },
            ],
        }),
        defineField({
            name: 'guest',
            title: 'Guest Author',
            type: 'object',
            fields: [
                defineField({ name: 'name', type: 'string', title: 'Guest Author Name' }),
                defineField({ name: 'site', type: 'string', title: 'Guest Author Site' }),
            ],
        }),
    ],
})
```

[Validation cascade](#eda02ebc1582)

When referencing schema types from other types, such as when setting a document's fields to custom types, any "higher level" validation rules will override existing validation rules.

For example, if you have an `articleType` and `authorType` as shown in the example below, any rules applied to the field in `articleType` will override the `authorType` rules.

```
export const authorType = defineType({
  type: 'object',
  name: 'authorType',
  validation: (rule) => rule.custom(...)
})

export const articleType = defineType({
  type: 'document',
  name: 'articleType',
  fields: [
    defineField({
      type: 'authorType',
      validation: (rule) => rule.custom(...) // Overrides the authorType validation
    })
  ]
})
```

Was this page helpful?

Report issue

## Tasks for Sanity Studio [https://www.sanity.io/docs/studio/tasks]

# Tasks for Sanity Studio | Sanity Docs

Studio Last updated July 7, 2025

# Tasks for Sanity Studio

Copy article

Learn to use Sanity Studio's tasks for collaboration, assign tasks, comment on tasks, and resolve tasks for efficient content creation.

Tasks for Sanity Studio are perfect for collaborating on content with your team, or even for solo content creators who need to keep track of their outstanding to-doâ€™s in the same environment where the work is to be done. Assign tasks to the appropriate team member, and they will get a notification alerting them to the new item in their inbox. Keep the discussion going in dedicated comment threads for every task, and tag in those who might be missing out with *@mention* â€™s.

#### This is a paid feature

This feature is available in the [Growth plan.](/pricing)

#### Configuring Tasks

Enable and configure the Tasks feature in Sanity Studio

#### Comments in Sanity Studio

Learn how to set up and use the Comments feature for collaborative content creation

[Working with tasks](#e7ba71030cee) [Find your tasks inbox](#a137ce45b845)

Your tasks inbox is located in the top-right corner of your studio, next to your profile picture. Here, youâ€™ll find any new tasks assigned to you, any in-progress tasks that youâ€™ve subscribed to, and all open tasks for the currently active document, whether or not youâ€™ve been tagged in yet.

[Create a task](#c94c12cb4179)

Click the link aptly labeled **+ New task** to create a new task. You can give your task a deadline, and assign it to the appropriate person who will then receive a notification email. You can also *@mention* studio users to notify them that their input is requested.

#### Protip

Memo to self? Assigning a task to yourself, or @mentioning yourself in a task will not trigger any notifications, so talking to yourself in the studio is perfectly fine, and wonâ€™t flood your inbox.

You can also choose to attach your task to a target document or leave it empty if thatâ€™s more appropriate. Adding a target document facilitates discovery and contextualizing, and will also put a handy notice next to the publish button for the relevant document, listing unfinished tasks.

[Comment on tasks](#k9e81731c6841)

Tasks can have comment threads attached so you can keep related discussions in one easy to find place. Just as with comments elsewhere you can *@mention* your team members to let them know about discussions they should be aware of.

[Resolve tasks](#d0b06936cfac)

Once dealt with, a task can be satisfactorily checked off your to-do list. Resolved tasks are still available by accessing the list of **Done** tasks at the bottom of your inbox.

Was this page helpful?

Report issue

## Manage Studio notifications [https://www.sanity.io/docs/studio/studio-notifications]

# Manage Studio notifications | Sanity Docs

Studio Last updated July 31, 2025

# Manage Studio notifications

Copy article

Manage your Sanity Studio notifications from the user account settings page.

You can enable/disable email notifications for your account from the Dashboard, or from [sanity.io/manage](https://www.sanity.io/manage) .

Comment notifications are account-wide for a user, and will apply to all organizations and studios. Notifications for other users are unaffected.

- Select the **user avatar** to open a popover menu. In the dashboard, this is located in the bottom-left corner. In Manage or standalone studios, this is located in the top-right corner.
- Select **Account settings** to navigate to the setting page for your user account.

Once on the settings page, toggle the setting under "Comment notifications".

Was this page helpful?

Report issue

## Schema [https://www.sanity.io/docs/schema-types]

# Schema | Sanity Docs

Studio Last updated July 8, 2025

# Schema

Copy article

A schema describes the types of documents and fields editors may author in a Sanity Studio workspace.

The top level `schema` configuration accepts an object with two properties: `templates` and `types:`

* The templates property accepts an array of Initial Value Template configuration objects or a callback function returning the same.
* The types property accepts an array of schema definition objects or a callback function returning the same.

In both cases, the callback function is called with the current value as the first argument and a context object as the second. Thus, you can access schema definitions and Initial Value Templates implemented by plugins.

[templates](#templates-3b7c7ccbff27) array | function

An array of initial value templates , or a callback function that resolves to the same.
[types](#types-8137822cbda1) array | function

An array of schema definitions or a callback function that resolves to the same.

The `templates` property is discussed in greater detail [in this article](/docs/studio/initial-value-templates) , and a reference article can be found [here](/docs/studio/initial-value-templates-api) . The rest of this article will deal with the default set of schema types supported in the Sanity Studio.

All schema types are listed below or in the documentation menu.

#### Array

Schema type for arrays of other types.

#### Block

Schema type for block which provides a rich text editor for block content.

#### Boolean

Schema type reference for expressing truthy values.

#### Cross Dataset References

All you need to know about creating references across datasets.

#### Date

Schema type reference for the Date type.

#### Datetime

The schema type for expressing an exact date and time.

#### Document

Schema type reference for expressing documents.

#### File

Schema type reference for the File type.

#### Geopoint

Schema type reference for the geopoint type.

#### Image

Schema type for uploading, selecting, and editing images.

#### Number

Schema type reference for the Number type.

#### Object

Schema type to create custom types to use in a document.

#### Reference

A schema type for referencing other documents.

#### Slug

A schema type for slugs is typically used to create unique URLs.

#### String

A schema type for strings and a selectable lists of strings.

#### Span

Schema type reference for the Span type.

#### Text

Schema type reference for the Text type.

#### URL

Schema type reference for the URL type.

#### Global Document Reference

Schema type reference documentation for Global Document References.

[Properties](#k95998f28-7255-47eb-9def-7579c5688282)

Required [type](#type-798d15a99732) string

Name of any valid schema type *.* This will be the type of the value in the data record.
Required [name](#name-6761a57a116e) string

The field name. This will be the key in the data record.
[title](#title-9bbaa7c16f19) string

Human readable label for the field.
[hidden](#hidden-a6b799ef04e2) boolean | () => boolean

Takes a static or a callback function that resolves to a boolean value and hides the given field based on it. You can use this property for conditional fields.
[readOnly](#readonly-476941e109de) boolean | ()=>boolean

If set to true , this field will not be editable in the content studio. You can also return a callback function to use it as a conditional field.
[description](#description-a91f4a01ca4e) string

Short description to editors how the field is to be used.
[deprecated](#deprecated-0a92c2f603c9) object

Marks a document type or a field as deprecated. This will render the field(s) as read-only with a visual deprecation message defined by the reason property.
Example: deprecated: { reason: 'no longer used' }
If you deploy a GraphQL API schema, this property will translated into the @deprecated directive.
[options](#options-646e00663aba) object

A unique set of options depending on the type. See the individual schema type references for available options.
[validation](#validation-2fc0ab4b6082) RuleBuilder

Enables adding one or more validation rules to the field. See the validation guide for more details, the section below for common validation methods, and the individual schema type references for additional methods.

[Validation](#a80ae6e5-1de7-4692-88f9-845a4a1678fc)

[required()](#required-eda9af2f2c00)

Ensures the field exists.
Example: (Rule) => Rule.required()
[either([rule, rule, ...])](#either-rule-rule-adcf41d09916)

Accepts an array of rules. If any are truthy, the validation passes.
Example: (rule) => rule.either([rule.required().min(1), rule.custom((_, context) => context.document?.category !== 'bicycle')])
[all([rule, rule, ...])](#all-rule-rule-c914a2929e5a)

Accepts an array of multiple rules, all of which must be true for the validation to pass.
Example: (rule) => rule.all([rule.required(), rule.custom((value, context) => { ... })])
[custom(value, context)](#custom-value-context-9fd616127457)

Allows for custom validation rules. Receives the field value and the context. Must return true if validation passes, or an error message if validation fails.
Example: rule => rule.custom(value => { ... })

**Note** : The properties listed above are common for all data types. For a more thorough description of how to use them, see the individual schema type references.

[Schema organization tips](#k4d55bb107ed4)

The studio loads all schemas defined under `schema.types` in `studio.config.js` .

```
//sanity.config.js
import
{
defineConfig
}
from
'
sanity
'
export
default
defineConfig
({
/* ... */
schema
:
{
types
:
[
{
title
:
"
My Example Document Type
"
,
name
:
"
exampleDocumentType
"
,
type
:
"
document
"
,
fields
:
[
{
title
:
"
Greeting
"
,
name
:
"
greeting
"
,
type
:
"
string
"
}
]
}
]
}
})
```

To keep things organized, consider keeping the types array in a separate file and import it into `studio.config.js` .

```
//schemaTypes.js
export
const
schemaTypes
=
[
{
title
:
"
My Example Document Type
"
,
name
:
"
exampleDocumentType
"
,
type
:
"
document
"
,
fields
:
[
{
title
:
"
Greeting
"
,
name
:
"
greeting
"
,
type
:
"
string
"
}
]
}
]
//sanity.config.js
import
{
defineConfig
}
from
'
sanity
'
import
{
schemaTypes
}
from
'
./schemaTypes
'
export
default
defineConfig
({
/* ... */
schema
:
{
types
:
schemaTypes
}
})
```

You should also consider using the `defineType` , `defineField` and `defineArrayMember` helper functions when working with schemas. These will give you better IDE auto-suggestions and provide type-safety when used in TypeScript files. Using these functions is *completely optional.*

```
import
{
defineType
,
defineField
,
defineArrayMember
}
from
'
sanity
'
export
const
someDocumentType
=
defineType
({
title
:
"
Some Document Type
"
,
name
:
"
exampleDocumentType
"
,
type
:
"
document
"
,
fields
:
[
defineField
({
title
:
"
String array
"
,
name
:
"
strings
"
,
type
:
"
array
"
,
of
:
[
defineArrayMember
({
type
:
"
string
"
})
]
})
]
})
```

[Plugins](#k2e61273860da)

Plugins may also provide types. They will be available in the studio exactly like studio configured types.

Using plugins to organize your code can be helpful as the studio codebase grows.

```
// pluginWithSchema.js
import
{
definePlugin
,
defineType
,
defineField
}
from
'
sanity
'
export
const
pluginWithSchema
=
definePlugin
({
name
:
'
plugin-with-schema
'
,
schema
:
{
types
:
[
defineType
({
title
:
"
Plugin object
"
,
name
:
"
exampleObject
"
,
type
:
"
document
"
,
fields
:
[
defineField
({
title
:
"
Title
"
,
name
:
"
title
"
,
type
:
"
string
"
})
]
})
]
}
})
//sanity.config.js
import
{
defineConfig
}
from
'
sanity
'
import
{
pluginWithSchema
}
from
'
./pluginWithSchema
'
export
default
defineConfig
({
/* ... */
plugins
:
[
pluginWithSchema
()]
})
```

Was this page helpful?

Report issue

## Migrating your schema and content [https://www.sanity.io/docs/content-lake/schema-and-content-migrations]

# Migrating your schema and content | Sanity Docs

Content Lake (Datastore) Last updated July 23, 2025

# Migrating your schema and content

Copy article

How to migrate schema and content within a Sanity project

Most projects will require changes to [the schema](/docs/schema-types) , that is, your content model. At the start of a project, these changes are often additive and only involve building out the schema with new document and field types. There will be no actual content that needs to be changed.

However, sometimes, you must change the existing schema and content in your Sanity Studio and Content Lake dataset (and maybe for your GraphQL API). Maybe you want to rename a field, add a new validation rule, check how existing documents will be affected, or move fields into an array or object type. There are many valid and necessary reasons to change and evolve your schema and the content that goes with it.

While changing a Sanity Studio schema is most often straightforward, if you have content in documents that assumes a certain structure, you will want to migrate these to match your updated schema. This is where our tools for schema change management come in.

#### Introduction to Schema Change Management

This course introduces you to schema and content migrations in a step-by-step manner.

#### Content migration cheat sheet

Copy-paste common content migration code snippets

#### Important considerations for schema change management

How to approach schema changes for projects in and out of production

#### CLI tooling for validations

Reference docs for checking document validation status across a dataset

#### CLI tooling for content migrations

Reference docs for working with migrations in the CLI

[What is schema change management?](#k1783ecb978d2)

The process of changing your schema and existing content is called â€œschema change management.â€ This is comparable to what other content management systems call â€œcontent migrations,â€ but it goes beyond that. Schema change management is about what you must think about when changing the structure of your content or the validation rules of your field and document types.

In some contexts, â€œcontent migrationsâ€ might refer to cases where you go from one content management system to another. While the following can be useful as part of that process, this article and the features we address focus on migrations *within* a dataset in a Sanity project.

Common examples of schema change management:

- You need to change a schema for a Sanity Studio workspace and wish to update existing content to validate against the new schema update
- You have imported content from another content management system (CMS) and wish to change and improve its structure
- You have added new validation rules and wish to introspect and list documents that need to be updated by a content team or a content migration script
- You are crafting an NDJSON import file and want to validate the documents before importing them into your dataset
- You just want insight into the validation status across your whole dataset (as opposed to per document in the Studio) to troubleshoot implementation bugs

#### Gotcha

Itâ€™s important to note that changing the schema for a Sanity Studio workspace will **not** automatically change or delete existing content in your dataset.

We consider this a feature that helps prevent unintended breakage for applications that rely on your content model having a certain shape. As with databases, you want changes to the content model (or data model) to be intentional, preferably reproducible, and part of your development workflow.

Sanity offers tooling to bring existing content up to date so you have flexibility in adding, removing, and changing the shape of your content.

[Tooling for schema and content migrations in a dataset](#d3920b5ad736)

Sanity offers tooling and capabilities that support schema migrations:

- The [deprecated](/docs/schema-types) property lets you mark document and field types that shouldnâ€™t be used anymore with a defined reason . This configuration will appear visually in the Sanity Studio and part of the [GraphQL API schema](/docs/content-lake/graphql) for those using this feature.
- Command Line Interface (CLI) commands:* [sanity documents validate](/docs/cli-reference/documents) lets you check the validation status of documents in a dataset or export file
* [sanity schema validate](/docs/cli-reference/cli-schema) lets you identify potential errors in your schema configuration (is also run by sanity documents validate )
* [sanity migration [command]](/docs/cli-reference/cli-migration) lets you create, list, and run content migrations (defined in code) with helper functions for defining how documents should change
* [sanity dataset import|export](/docs/cli-reference/dataset) (or using [Advanced Dataset Management](/docs/content-lake/how-to-use-cloud-clone-for-datasets) ) lets you export/import datasets to test and validate a migration in a non-production environment
- If you have needs beyond what the current tooling gives you, you can also use the [Sanity Content Lake APIs](/docs/http-api) for directly querying and mutating content.

[Deprecating document and field types](#k427cd19d541b)

While you can add, change, and remove schema types freely without cascading changes to existing content, chances are you want to be more considered, especially for projects running in production. Often, you want content teams to be able to see and (sometimes) edit) a deprecated field and explain why and how a schema type has been changed.

All user-configurable schema types support explicit deprecation through a configuration property called `deprecated` where the value is an object with a defined `reason` as a string (required):

```
export const person = defineType({
  name: 'person',
  type: 'document',
  deprecated: {
    reason: 'Use the Author document type instead.'
  },
  fields: [],
  readOnly: true // to prevent further edits
})
```

You can use the `readOnly: true` configuration to prevent deprecated fields and documents from being edited.

```
export const name = defineField({
  name: 'firstName',
  type: 'string',
  description: `The person's first name`,
  deprecated: {
    reason: 'Use the name field instead.'
  },
  readOnly: true, // to prevent further edits,
})
```

This configuration will show up visually in the studio:

*In this example, both the document type and the title field have been deprecated.*

Our GraphQL API also supports the deprecation property, which translates the property and reason into the [directives for deprecations in the GraphQL specification](https://spec.graphql.org/October2021/#sec--deprecated) .

[Checking validating status across all documents in a dataset](#b9ea24e2a1e3)

Validation rules for document and field types are primarily shown within a document form for users of Sanity Studio. However, when working with schema and content migration, it is useful to review the validation status for all documents in a dataset, especially for quickly getting insight into the state of your datasets and helping you decide what migrations jobs to create.

The Sanity CLI offers this functionality with `sanity documents validate` . This command runs all `validation` rules in your current schema configuration on documents in a virtual browser environment from where the command is run. In addition, it can also report on document types, that is, documents with a `_type` that is not covered in your schema configuration.

Without any extra flags, `sanity documents validate` will output a pretty formatted list of validation errors and warnings from the project and dataset defined in `sanity.cli.ts` . It will also give you actionable Studio links, provided you have configured a Studio URL in the project settings on [sanity.io/manage](https://www.sanity.io/manage) .

You can use flags to specify specific Studio workspace (if it has more than one), dataset name, validation level ( `error` , `warning` , `info` ), and output formats ( `pretty` , `json` , `ndjson` ).

You can also use the `--file [file path]` flag to run validations against a dataset import/export file (supports both `filename.ndjson` or `filename.tar.gz` ).

[The anatomy of the validation output](#k809a66e4e045)

When exporting to a JSON format, the output of the CLI gives you actionable data such as the document ID (the same as `_id` ) and type (the same as `_type` ), the revision ID, the URL to find the document in a deployed Studio, as well as an array with all validation notices that it can have. The `level` property on the root of this object will always reflect the most severe level in the markers array, from â€œerror,â€ â€œwarning,â€ to â€œinfo.

```
{
    "documentId": "person_robin-sachs",
    "documentType": "person",
    "revision": "GspWPjs815p7KTxv2q3x76",
    "intentUrl": "https://schema-change-management-demo.sanity.studio/intent/edit/id=person_robin-sachs;type=person",
    "markers": [
      {
        "path": ["fullName"],
        "level": "warning",
        "message": "Field 'fullName' does not exist on type 'person'"
      }
    ],
    "level": "warning"
  }
```

[A lot of validation errors? Pipe the output to a file!](#k92f71245bbc8)

If you have a sizeable dataset and/or a bunch of validation errors, the output will likely overflow your terminalâ€™s buffer. In these cases, piping the output to a file in the terminal can be useful. For most shell environments, it will look something like this:

```
sanity documents validate -y --format ndjson > documentValidations.ndjson
```

A pro tip is that you can then use [GROQ CLI](https://github.com/sanity-io/groq-cli) to parse this file. Letâ€™s say you wanted to have a list of Studio URLs of all documents that have a validation error (and not just a `warning` ):

```
# npm install --global groq-cli
cat documentValidations.ndjson|groq -n "*[level == 'error'].intentUrl"
```

[Working with content migrations in the CLI](#af2be129ccd6)

The Sanity CLI has tooling for creating and running content migrations against a dataset. Content migrations are described in JavaScript (or TypeScript) as files inside a `migrations` folder in your Sanity Studio project. You can also automate and run content migration as part of a CD/CI pipeline.

[Creating new content migrations](#k0c3fe37dc985)

You can use the CLI command `sanity migration create` to create a new content migration file. The CLI will prompt you for a human-friendly title, which document types you want to filter on, and a content migration template to start from. You can also go to [the content migration cheat sheet](/docs/content-lake/content-migration-cheatsheet) to find starting points for common migration patterns.

[File and folder structure](#k1b33051c4920)

The sanity migration CLI command will create and look for migration files in a `migrations` folder, when run from the Studio project root. You can write migration files in JavaScript ( `.js` , `.mjs` , `.cjs` ) and TypeScript ( `.ts` ).

You can store migration script in two patterns, that can also be combined:

- studioFolder/migrations/my-content-migration.ts
- studioFolder/migrations/my-content-migration/index.ts

The latter is useful when you have a complex migration and want to split up the code in more files.

[The anatomy of a content migration file](#f17a561304a6)

A migration file should export a `defineMigration` (using `default export` ) with the following configuration:

- title : A reader-friendly description of what the content migration does
- documentTypes : an array of document types to run the content migration on. If you donâ€™t define this, the migration type will target all document types.
- filter : A simple GROQ-filter (doesnâ€™t support joins) for documents you want to run the content migration on
- migrate : an object of named helper functions corresponding to the primary schema type of the content you want to migrate. You can also run these functions as async and return the migration instructions as promises if you need to fetch data from elsewhere

```
// migrations/example-migration/index.ts
import {defineMigration} from 'sanity/migrate'

export default defineMigration({
  title: 'A human-friendly description of what this content migration does',
  documentTypes: ['aDocumentType'],
  migrate: {
    document(doc, context) {
      // this will be called for every document of the matching type
    },
    node(node, path, context) {
      // this will be called for every node in every document of the matching type
    },
    object(node, path, context) {
      // this will be called for every object node in every document of the matching type
    },
    array(node, path, context) {
      // this will be called for every array node in every document of the matching type
    },
    string(node, path, context) {
      // this will be called for every string node in every document of the matching type
    },
    number(node, path, context) {
      // this will be called for every number node in every document of the matching type
    },
    boolean(node, path, context) {
      // this will be called for every boolean node in every document of the matching type
    },
    null(node, path, context) {
      // this will be called for every null node in every document of the matching type
    },
  },
})
```

#### Content migrations cheat sheet

[Understanding node in the context of content migrations](#f52542385e04)

We refer to â€œnodeâ€ in the code example above and that there is a mutation creator function for `node(node, path, context)` . Here, a â€œnodeâ€ refers to any value in a document, including nested ones.

The `object` , `array` , `string` , `number` , `boolean` , and `null` functions are subsets of the node function to make it easier to access content by its JSON data type.

The `node` as the first argument in these functions will be the value for any given node.

The `path` will tell you where the `node` value comes from in the document. This is where you will find any node's key/property/field name and the `_key` value in array data.

#### Protip
